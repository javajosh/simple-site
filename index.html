<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Function Idea</title>
	<script src="node_modules/jquery/dist/jquery.js"></script>
	<script src="node_modules/markdown/lib/markdown.js"></script>
	<script src="deparam.js"></script>
</head>
<body>
	<h1>Function Idea</h1>
	<p>Treat the URL as a function invocation. Do it in two steps: first, define a higher-order function that takes an object and invokes another function based on it's properties. E.g. ?f=foobar would yield {f:'foobar'} would invoke <i>foobar()</i>. This nicely generalizes to arguments, e.g. f=foobar&amp;a=1&amp;a=2 would yield {f:'foobar', a:1, b:2} would be <i>foobar(1,2)</i> (or perhaps better <i>foobar({a:1, b:2})</i> since we can't really do ordering.)</p>

	<p>This is not just any function, of course, it's a top-level function in the application. It's something a developer might type at the command line. In general it might talk to the network, and it might affect the screen - probably both. In that sense the function should be considered a kind of <i>navigation function</i> in that these parameters are for reading only. (It generalizes to write preparation, but not to writing itself. Hopefully we'll get to that later!)</p>

	<p>First things first, some simple test code. What are we talking about?</p>
	<script>
		function foobar(o){
			console.log('foobar()', o);
		}
	</script>
	<p>Okay we've defined a new function, <i>foobar()</i>, that takes no arguments and just prints out it's own name to the console. Let's start by invoking it with an object.</p>
	<script>
		var forbidRedundantState = true;
		function equals(a,b){
			assert(typeof a === 'object');
			assert(typeof b === 'object');
			var a1 = JSON.stringify(a);
			var b1 = JSON.stringify(b);
			return a1 == b1;
		}
		function assert(p, msg){if (!p) throw 'assertion failed: ' + msg;}
		function invoke(o, isHistory){
			assert(typeof o === 'object', 'invoke only takes objects');
			assert(typeof o.f === 'string', 'invoke object requires a string f parameter');
			assert(typeof window[o.f] === 'function', 'function not found ' + o.f);
			if (forbidRedundantState && !isHistory) assert(!equals(o,history.state), 'redundant state');

			var f = window[o.f];
			f(o);
			
			if (!isHistory) history.pushState(o, JSON.stringify(o), '?' + $.param(o));
			
		}
	</script>
	<div onclick="eval(arguments[0].target.innerHTML)">
		<button>invoke()</button>
		<button>invoke({})</button>
		<button>invoke({f:'nonsense'})</button>
		<button>invoke({f:'foobar'})</button>
	</div>
	<p>Okay, that worked great. Now we need a way to get an object in and out of a URL. The most general way to do this is with jQuery BBQ (or just param/deparam)</p>
	<script>
		//Let's give param and deparam a whirl.
		var str = $.param({f:'nonsense', a:1});
		var obj = $.deparam(str, true);
		console.log(str, obj);
	</script>
	<script>
		var count = 0;
		function counter(o){
			assert(typeof o.i === 'number', 'counter only takes numbers');
			assert(o.i > 0, 'counter only takes positive numbers');
			count += o.i;
			console.log(count);
		}
	</script>
	<div onclick="eval(arguments[0].target.innerHTML)">
		<button>invoke({f:'counter'})</button>
		<button>invoke({f:'counter', i:'a'})</button>
		<button>invoke({f:'counter', i:-1})</button>
		<button>invoke({f:'counter', i:1})</button>
		<button>invoke({f:'counter', i:10})</button>
	</div>
	<p>This sort of works, but it's a bad example of API design. The state of the page is not recoverable from these objects! We'd do better with an explicit <i>set</i> style function.</p>
	<script>
		function set(o){
			assert(typeof o.key === 'string', 'key required');
			assert(typeof o.value !== 'undefined', 'value required');
			window[o.key] = o.value;
			console.log(o.key, 'set to', o.value);
		}
	</script>
	<div onclick="eval(arguments[0].target.innerHTML)">
		<button>invoke({f:'set'})</button>
		<button>invoke({f:'set', key:1})</button>
		<button>invoke({f:'set', key: 'a'})</button>
		<button>invoke({f:'set', key: 'a', value: 1})</button>
		<button>invoke({f:'set', key: 'a', value: 'foo'})</button>
	</div>
	<p>That's better. Next thing is to support the back button.</p>
	<script>
		window.onpopstate = function(e){
			console.log(e);
			invoke(e.state, true);
		}
	</script>
	<p>For an SPA, the function we want to invoke is a view state with some parameter that will help an ajax call get the rest of the data we need. This is simple when we only have a single view state.</p>
	<script>
		var users = [{name: 'alice', weight:100},{name: 'bob', weight:200}];
		function user(o){
			assert(typeof o.id === 'number', 'user requires a numeric id');
			if (typeof o.user === 'object'){
				renderUser(o.user);
				return;
			}
			getUserForID(o.id, function(user){
				renderUser(user);
				o.user = user;
			});
		}
		function getUserForID(id, cb){
			assert(id < users.length, 'id must be a valid index < user length: ' + users.length);
			cb(users[id]); 
		}
		function renderUser(user){
			console.log(user);
		}
	</script>
	<div onclick="eval(arguments[0].target.innerHTML)">
		<button>invoke({f:'user'})</button>
		<button>invoke({f:'user', id:-1})</button>
		<button>invoke({f:'user', id: 3})</button>
		<button>invoke({f:'user', id: 0})</button>
		<button>invoke({f:'user', id: 1})</button>
	</div>
	
	<p>So there are a couple of ways to go now. First is to support multiple simultaneous invocations, which means to support multiple simultaneous states (which is what BBQ provides). Another option is to flesh out more the structure of <i>get and render</i> especially as callbacks and with caching. Another is to apply this pattern to <i>major transition state</i> in an SPA.</p>

	<script>
		//Let's make sure that we can match things properly.
		var name = "bob";
		var pattern  = "bo.";
		var regExp = new RegExp(pattern);
		var matches = regExp.test(name);
		
		function search(o){
			
			var tests = [];
			var results = [];
			if (o.name) {
				assert(typeof o.name === 'string', 'name should be a string');
				var regExp = new RegExp(o.name);
				var test = function(user){return regExp.test(user.name);}
				test.regExp = regExp;
				test.pattern = o.name;
				tests.push(test);
			}
			if (o.minWeight) {
				assert(typeof o.minWeight === 'number', 'minWeight should be a number');
				var test = function(user){return user.weight >= o.minWeight;};
				test.minWeight = o.minWeight;
				tests.push(test);
			}
			if (o.maxWeight) {
				assert(typeof o.maxWeight === 'number', 'maxWeight should be a number');
				var test = function(user){return user.weight <= o.maxWeight;};
				test.maxWeight = o.maxWeight;
				tests.push(test);
			}

			if (tests.length === 0) results = users;

			//run every test on every user
			for (var i = 0; i < users.length; i++) {
				var user = users[i];
				var passedAll = true;
				for (var j = 0; j < tests.length; j++) {
					passedAll = passedAll && tests[j](user);
				};
				if (passedAll) results.push(user);
			};
			console.log(tests, results);

		}
	</script>
	<div onclick="eval(arguments[0].target.innerHTML)">
		<button>invoke({f:'search'})</button>
		<button>invoke({f:'search', name:'bob'})</button>
		<button>invoke({f:'search', name:'a.*'})</button>
		<button>invoke({f:'search', minWeight: 110})</button>
		<button>invoke({f:'search', maxWeight: 110})</button>
		<button>invoke({f:'search', minWeight: 110, maxWeight: 210})</button>
	</div>

	<p>One of the things I noticed is that when I load the page with a long URL, the function is not <i>invoke()</i>'d. Let's fix that. The basic idea is to examine the URL string on initial page load, parse it into an object, and then call invoke on (part of) it.</p>

	<pre>
		var url = window.location.search.slice(1);
		var o1 = $.deparam(url, true);
		console.log(url, o1);
		invoke(o1);
	</pre>
	<script>
		var url = window.location.search.slice(1);
		var o1 = $.deparam(url, true);
		console.log(url, o1);
		invoke(o1);
	</script>

	<p>Well that's cool because you can <i>type</i> new states into the URL and they do exactly what you expect. For the future I'd like to write a function that infers the 'f' parameter from the names of the other parameters. I'd also like to think more about caching - not only adding data to the pushState object, but also keeping data around in the browser for a while. (This is a kind of memoization of search).</p>

</body>
</html>